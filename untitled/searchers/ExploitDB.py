# coding=utf-8
from __future__ import division, unicode_literals

import csv
import re
import requests
import sys
from bs4 import BeautifulSoup
from collections import Counter
from datetime import datetime

from .Searcher import Searcher
from ..models import Exploit

"""
NOTE
 The "CVE Reference Map for Source EXPLOIT-DB"
 at https://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html
 appears to be missing lots of exploits before 2006 or something
"""


# TODO: Maybe use the ZIPPED version https://github.com/Gioyik/getExploit/blob/master/getExploit.py
# and maybe steal ideas

# TODO: Make a global Requests Session object...

class ExploitDB(Searcher):
    """This classes searches for exploits at https://www.exploit-db.com/."""

    def setup(self, searchByString=True):
        """Setup method used for initialisation purposes by every Scanner."""
        super(ExploitDB, self).setup()
        self.dbUrl = "https://raw.githubusercontent.com/offensive-security/exploit-database/master/files.csv"
        self.idToCVEurl = "https://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html"
        self.exploitUrl = "https://www.exploit-db.com/exploits/"
        self.description = "Searches for exploits at https://www.exploit-db.com"
        self.starredWords = []
        self.searchTerms = []

        if searchByString:
            for w in self.search_string.split():
                if w != "*":
                    self.searchTerms.append(w.lower().strip("*"))
                    if "*" in w:
                        self.starredWords.append(w.lower().strip("*"))

        self._exploitDB = self.loadDB()

    def buildExploit(self, _exploit):
        e = Exploit()
        e.date = datetime.strptime(_exploit[3], "%Y-%m-%d")
        e.desc = _exploit[2]
        e.url = self.exploitUrl + _exploit[0] + "/"
        if self.cve:
            # if searching with CVE, return that one
            e.cve = self.cve
        else:
            # try to fetch the CVE from Exploit's page
            # there is probably no clean way of doing this
            # unless if I can scrap the exploit-db page
            # but they block me .
            e.cve = self.fetchCVE(e)
        return e

    def fetchCVE(self, e):
        try:
            # TODO: Exploit-DB wont be happy with this probably!!!!
            # TODO: Discuss?!?
            with requests.Session() as s:
                html = s.get(e.url, headers={'User-Agent': 'Mozilla/5.0'})
                soup = BeautifulSoup(html.content, 'html.parser')
                startTable = soup.find_all('table', class_='exploit_list')
                cve = startTable[0].find_all('a', string=re.compile('CVE-\d{4}-\d{4,7}'))
                for i in cve:
                    for j in i.contents:
                        if re.search('CVE-\d{4}-\d{4,7}', j):
                            return j.strip()
        except BaseException as e:
            self.log.warn("Something went wrong while trying to scrape exploit's CVE number: {}".format(e))
            return "N/A"

        return "N/A"

    def findExploitsByCVE(self):
        """Searches for exploits using a CVE number."""
        self.expID = self.mapCVEtoExploitDB()

        for exp in csv.reader(self._exploitDB):
            if self.expID and exp[0] == self.expID and len(self.exploits) < self.limit:
                self.exploits.append(self.buildExploit(exp))

    def rankSearchTerm(self, term):
        # TODO: properly fix the ranking
        if self.wFreq[term] == 0:
            return 0
        return 1 / self.wFreq[term]

    def findExploitsByString(self):
        """Searches for exploits using the user's string input."""
        _exploits = []
        for exp in csv.reader(self._exploitDB):
            for w in exp[2].split():
                w.lower()

        self.wFreq = Counter([w.lower() for exp in csv.reader(self._exploitDB) for w in exp[2].split()])
        # find all relevant exploits sorting by most relevant
        for exp in csv.reader(self._exploitDB):
            cnt = 0
            # compare each word in exploit desc with user search terms
            for term in self.searchTerms:
                # keep the unique lower cased words from ExploitDB descriptions
                descWordList = list(set([word.lower() for word in exp[2].split()]))
                for word in descWordList:
                    if term.lower() in word:
                        # TODO remove starred words
                        if term in self.starredWords:
                            # Ugly quick way to fully prioritize starred keywords
                            cnt += len(self.searchTerms)
                        else:
                            cnt += (1 * self.rankSearchTerm(term))

            # add into the list if at least 1 word was found
            if cnt > 0:
                _exploits.append((cnt, exp))

        # sort in DESC mode
        temp_exploits = [exp[1] for exp in sorted(_exploits, key=lambda tup: tup[0], reverse=True)]
        self.log.debug('Sorting exploits')

        if self.limit > 0:
            for exp in temp_exploits[:self.limit]:
                self.exploits.append(self.buildExploit(exp))
        else:
            for exp in temp_exploits:
                self.exploits.append(self.buildExploit(exp))

    def mapCVEtoExploitDB(self):
        """Maps CVE numbers to Exploit-DB's IDs scrapping an online map table."""

        # TODO: If more CVEs found for an ID, display a message coz they may be relevant?

        try:
            with requests.Session() as s:
                self.log.info('Requesting {}'.format(self.idToCVEurl))
                html = s.get(self.idToCVEurl)
                soup = BeautifulSoup(html.content, 'html.parser')
                ids = soup.find_all('td', string=re.compile('EXPLOIT-DB\:'))
                # self.log.debug('Parsed ID: {}'.format(ids))
                for _id in ids:
                    # Keep the ID numeric value out of the whole EXPLOIT-DB:<ID> text
                    try:
                        exploID = int(re.findall('\d+', str(_id))[0])
                    except TypeError as e:
                        self.log.warn('Failed to convert exploit-db ID to integer: {}'.format(e))
                        sys.exit(1)
                    # Ugly way to keep only the CVEs from soup's returning list which
                    # includes newline and whitespace elements also
                    try:
                        if self.cve in [i for i in (_id.find_next().find_all(string=True)) if len(i) > 2]:
                            return str(exploID)
                    except:  # god knows the possible exceptions
                        self.log.critical('Couldn\'t match CVE number to exploit-db ID')
                        sys.exit(1)
                # No Match found
                return False

        except requests.exceptions.Timeout as e:
            # Retry?
            self.log.info('Requesting {} timed out.. with error: {}'.format(self.idToCVEurl, e))
            return False
        except requests.exceptions.RequestException as e:
            self.log.info('Failed to access: {}. Error: {}'.format(self.idToCVEurl, e))
            return False

    def loadDB(self):
        """Loads the Exploit-DB's CSV database from the relevant git repo."""

        try:
            with requests.Session() as s:
                self.log.info('Requesting {}'.format(self.dbUrl))
                download = s.get(self.dbUrl)
                dec_content = download.content.decode('utf-8').strip()
                # return csv.reader(dec_content.splitlines())
                return dec_content.splitlines()
        except requests.exceptions.Timeout:
            # retry?
            self.log.critical('The request for fetching the exploit-db database timed out, try to rerun it.')
            sys.exit(1)
        except requests.exceptions.RequestException as e:
            # maybe make a die() method for all these prints+exits
            # or handle exceptions in a less shitty way
            self.log.critical('Failed to download exploit-db database: {}'.format(e))
            sys.exit(1)
        except csv.Error as e:
            self.log.critical('Failed to process exploit-db database as CSV: {}'.format(e))
            sys.exit(1)
        except:
            self.log.critical('Something went terribly wrong while trying to load the exploit-db database..')
            sys.exit(1)
